
= Red Hat Advanced Cluster SecurityによるDevSecOpsとポリシーエンフォースメント

== OpenShift Pipelinesを使ってRed Hat Advanced Cluster Security for Kubernetesを自動化する

=== はじめに

本ワークショップでは、TektonオープンソースプロジェクトをベースとしたOpenShift Pipelinesを使用して、より包括的な継続的インテグレーションソリューションの一部としてRed Hat Advanced Cluster Security for Kubernetesの実行を自動化する方法を説明します。その目的は、Kubernetesリソースの検証を継続的インテグレーションプロセスに導入し、定義されたポリシーに対する違反があれば、開発ライフサイクルの早い段階で対処できるようにすることにあります。

== パイプラインの要件と必要な機能

=== RHACSコマンドラインインターフェース

Red Hat Advanced Cluster Security for Kubernetesには、RHACSサーバーに保持されているポリシー定義に対してイメージやリソースを評価するためのコマンドラインインターフェイス *roxctl* があります。コマンドラインインターフェイスは、アドホックに使用するためにRHACSウェブユーザーインターフェイスからダウンロードすることができ、ここで紹介する自動化ステップでは、分析の各実行中にRHACSサーバーからroxctlがダウンロードされます。これにより、サーバーと一致する正しいバージョンが常に使用されることが保証されます。


=== roxctl 分析オプション

roxctlコマンドラインインターフェイスには、リソースやイメージの解析のためのオプションがいくつか用意されています。特に注目しているのはdeploymentオプションで、従来はKubernetesリソースのデプロイ準備状況を確認するために使用されていました。開発のビルド段階でこのオプションを使用することで、チームはデプロイ時期まで待つのではなく、より早い段階でデプロイの問題を把握することができます。これにより、チームは開発中に問題を修正することができ、コストを削減し、よりスムーズなデプロイメントにつなげることができます。


=== 継続的インテグレーションとroxctlプロセス
以下の例のCIプロセスは、ユーザーが独自の広範囲のOpenShift Pipelinesプロセスに構築できるタスク、スケルトンパイプライン、およびパイプライン実行リソースを利用しています。リソースとそれらの相互作用を図 1 に示します。

image::images/tekton-1.png[]

_図 1: OpenShift Pipeline process_ +

=== Pipeline Run リソース

OpenShift Pipelines の "pipeline run" リソースは、必要なパラメータを渡して、パイプラインリソースを呼び出します。パラメータの一部は上の図1で強調表示されており、すべてのパラメータは下の表で説明されています。パイプラインの実行では、"files"という10MBの永続的なボリュームにワークスペースを定義し、そこにソースアセットをクローンし、結果ファイルが書き込まれます。ここで説明するタスクを既存のOpenShift Pipelinesプロセスに追加したい場合は、パラメータ定義とワークスペース・ボリュームを既存のパイプライン・ランに追加してください。

|===
|Parameter|Description|Used by task

|acs_central_endpoint|RHACS セントラルサーバーの URL を含むシークレットの名前です。|Resource deployment check

|acs_api_token|RHACS Web ユーザーインターフェース内で生成されたアクセストークンを含むシークレットの名前です。 https://help-internal.stackrox.com/docs/integrate-with-other-tools/integrate-with-ci-systems/#configure-access[ここ] で説明されている、継続的インテグレーションアクセストークンです。|Resource deployment check

|上記2つのパラメータは、両方のデータ項目を含む1つのシークレットを参照することができます。||

|git-url|検証対象のリソースを含む GitHub リポジトリの URL です。|Git clone workspace

|git-revision|コンテンツをチェックアウトするために使用する識別子。(branch、tag、sha、ref...)|Git clone workspace

|file-location-in-git-repo|検査するリソースを含むディレクトリ。|Resource deployment check

|recursive-search|`true` の場合、上記のパスは、拡張子がyamlまたはymlのすべてのファイルに対して再帰的に検索されます。|Resource deployment check
|===



=== Pipeline リソース

前述のGitHubリポジトリにあるOpenShift Pipelinesの"pipeline"リソースが、タスクの実行とタスク間のパラメータの受け渡しをオーケストレーションしています。パイプラインの使い方については、「スキャン結果に基づく意思決定」の項で詳しく解説しています。

== Workshopセットアップ

=== Pipelineアセットをデプロイする

以下に説明するアセットは、GitHubの公開リポジトリ https://github.com/mfosterrox/demo.git で入手できます。アセットをデプロイするには、以下を実行します。

|===
*NOTE* 既存のフォルダを用意している場合は、*git clone* コマンドをスキップしてください。ただし、すべてのリソースが利用できるようにするために、コマンドを実行する必要があります。
|===

[source,bash,role="execute"]
----
git clone https://github.com/openshiftdemos/openshift-ops-workshops acs-workshop
----

[source,bash,role="execute"]
----
export TUTORIAL_HOME="$(pwd)/acs-workshop"
kubectl apply -f $TUTORIAL_HOME/workshop/demo-apps/configuration --recursive
kubectl apply -f $TUTORIAL_HOME/workshop/demo-apps/ --recursive
----

|===
*NOTE* このコマンドは、あなたの環境にたくさんの数のマニフェストを適用します。重要なのは、デプロイメントが稼働していることです。

次のコマンドを実行し、アプリケーションが稼働していることを確認します。
|===

[source,bash,role="execute"]
----
kubectl get deployments -l demo=acs -A
----

*出力* は以下のようになります。

```bash
NAMESPACE      NAME               READY   UP-TO-DATE   AVAILABLE   AGE
backend        api-server         1/1     1            1           0d
frontend       asset-cache        1/1     1            1           0d
log4shell      log4shell-app      3/3     3            3           0d
medical        reporting          1/1     1            1           0d
operations     jump-host          1/1     1            1           0d
payments       visa-processor     1/1     1            1           0d
spring4shell   spring4shell-app   3/3     3            3           0d
```

==== イメージスキャンPod Task

パイプラインの2つのタスクのうち、最初のタスクは *image scan test* タスクです。このタスクは、まず、スキャンするイメージをユーザに要求します。次に、roxctl CLI はこの情報をセントラルに送信し、分析を依頼します。ACS Centralは、イメージに関連する修正可能な脆弱性と修正不可能な脆弱性をすべて送り返します。*image scan* ファイルには、必要な変数、スキャンを完了するために必要な手順、およびスクリプトそのものが表示されます。

*image scan* タスクを表示するには、コマンドラインで以下を実行します。

[source,bash,role="execute"]
----
cat $TUTORIAL_HOME/workshop/demo-apps/pipelines/tasks/rox-image-scan-task.yml 
----

スキャンが完了したら、コンテナが特定のポリシーに違反していないかどうかをチェックする必要があります。

==== イメージチェックテスト Task

*image check test* は、ACSで有効化されたポリシーに対してスキャンされたイメージをチェックするよう、ACS centralに指示します。このファイルは、roxctlコマンドがファイルの主な違いである *image scan test* と非常によく似ています。

*image check* タスクを表示するには、コマンドラインで以下を実行します。

[source,bash,role="execute"]
----
cat $TUTORIAL_HOME/workshop/demo-apps/pipelines/tasks/rox-image-check-task.yml 
----

*ROX_CENTRAL_ENDPOINT* と *ROX_API_TOKEN* の2つの変数が両ファイルで欠落しています。パイプラインとクラスタが外部から侵入されないように、自動チェックには正しいアクセス権を与える必要があります。

次のステップでは、これらのコマンドを実行できるように、パイプラインにアクセス権を付与します。

=== CIプロセスの権限付与

まず、ACS centralにアクセスするためのトークンを作成する必要があります。

RHACSのWebユーザーインターフェースにアクセスし、左側のメニューから"Platform Configuration"を選択し、integrationsを選択します。認証トークンのセクションまでスクロールし、"StackRox API Token "を選択します。

image::images/ci-1.png[]

右上の *Generate Token* ボタンを押し、"Continuous Integration "というトークンの役割を選択します。トークンに名前を付け、"Generate"というタイトルのボタンを押します。

* 適当なトークン名を作成し、'Continuous Integration'ロールをクリックします。

image::images/ci-ja-2.png[]

* トークンを *rox-secrets.yml* ファイルに追加する必要があるため、必ずコピーしてください。

image::images/ci-ja-3.png[]

* 次に、demoディレクトリにある *rox-secrets.yml* ファイルを編集してください。vi/vim/nano/などお好みのコマンドラインエディタを使用して、以下のファイルにAPIトークンを追加してください。

----
$TUTORIAL_HOME/workshop/demo-apps/pipelines/pipeline/rox-secrets.yml 
----

|===
*NOTE* : *rox_api_token: "YOUR_API_TOKEN_HERE "* という行だけを変更することを確認してください。

|===

その後、変更内容を適用します。

[source,bash,role="execute"]
----
kubectl apply -f $TUTORIAL_HOME/workshop/demo-apps/pipelines/pipeline/rox-secrets.yml 
----

|===
*NOTE* : テキストエディタに不慣れな方は、OpenShiftコンソールから編集することもできます。Workloads -> Secretsに行き、'roxsecrets'をクリックし、YAMLタブに切り替えてそこで変更を加え、保存します。
|===

これで、パイプラインを実行する準備が整いました。

== Pipelineの実行

まず、パイプラインを実行するためにOpenShiftのコンソールで、*Pipelines* タブをクリックして、*Pipelines* ドロップダウンを選択します。

image::images/pipeline-1.png[]

*rox-pipeline* と書かれたパイプラインが表示されているはずです。ひとつ実行してみましょう。
パイプラインを実行するには、パイプラインの左にある3つの点をクリックして *start* をクリックするか、*rox-pipeline* をクリックして詳細ページに移動し、*actions -> start* を選択することができます。

image::images/pipeline-2.png[]

image::images/pipeline-3.png[]

* スキャンしたいイメージ（quay.io/mfoster/log4shell-demo:0.1.0）を追加する必要があります。今回は、log4shellの脆弱性があることが分かっているイメージを見たいと思います。

image::images/pipeline-ja-4.png[]

image::images/pipeline-ja-5.png[]

* startをクリックし、パイプラインが実行段階にあることを確認します。下の図のような状態になるはずです。

image::images/pipeline-5.png[]

image::images/pipeline-6.png[]

このイメージは失敗するように設計されているので、タスクのうち1つだけが通過します。したがって、結果は次のようになります。

image::images/pipeline-7.png[]

image::images/pipeline-8.png[]

上の画像から、ログの抜粋では、5つのポリシーが違反されていることがわかります。

* パイプラインの総出力を見るには、*Logs* タブをクリックします。

ログを展開すると、以下のような出力が得られます。

image::images/pipeline-9.png[]

ログには、ポリシーlog4shellがポリシーに違反のため、パイプラインを切断したことが示されています。

このチェックが他のビルド/デプロイパイプラインに追加された場合、脆弱なアプリのデプロイを前倒しで停止させることが可能です。

== Extra Challenge

もっとチャレンジしてみたいと思った場合は、次のことを試してみてください。

クラスタに配備された特定のCVE（Apache Struts violation=CVE-2013-1965）をターゲットにするポリシーを作成し、新しいコンテナでパイプラインを再度実行し、ポリシーがトリガーされるかどうか確認します

|===
*Hint:* まず重要な脆弱性を持つコンテナを見つけ、ポリシーを作成し、パイプラインを変更します。
|===
