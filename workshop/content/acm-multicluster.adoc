= Advanced Cluster Management for Kubernetes - RHACM

== クラスターとクラスターライフサイクルの操作

クラスターのライフサイクル管理は、マルチクラウド環境におけるクラスターの作成、アップグレード、破壊とインポートを高いレベルで行うものです。

本ワークショップ用のガイダンスページで、*ACM HubのURL*、*ユーザー名とパスワード*、*AWSの認証情報* 、*Access Key ID*  、*Secret Access Key ID*、*Base DNS Domain* を確認しておきます。

*ACM HubのURL* から *ユーザー名とパスワード* を使用してACMにログインした後、*Credentials menu* に移動し、*Add Credentials* を選択します。

image::images/acm-login.png[]

image::images/acm-add-credential.png[]

=== 接続のための詳細情報の作成

* Cloud Provider Credentials: *Amazon Web Services* を選びます。

image::images/acm-1-1.png[]

次の項目をテキストボックスに入力しましす。

* Credential Name:  `aws`
* Namespace: `open-cluster-management`
* Base DNS Domain:  この情報は、本ワークショップ用のガイダンスページの *rhacm_aws_subdomain* というフィールドの下にあります。 

この情報をコピー＆ペーストする場合、URLのドットを必ず省略してください。例えば、`.sandbox1536.opentlc.com` ではなく、`sandbox1536.opentlc.com` と記述します。

* NEXTをクリックします。

image::images/acm-1-2.png[]

次の項目をテキストボックスに入力しましす。

* Access Key ID: この情報は、本ワークショップ用のガイダンスページの *rhacm_aws_access_key_id* というフィールドの下にあります。

* Secret Access Key ID: この情報は、本ワークショップ用のガイダンスページの *rhacm_aws_secret_key* というフィールドの下にあります。

* NEXTをクリックします。 

image::images/acm-1-3.png[]

Proxyを設定する必要はないので、この項目は何も設定しません。

* NEXTをクリックします。

image::images/acm-1-4.png[]

https://cloud.redhat.com/openshift/install/pull-secret[cloud.redhat.com] にログインして pull secretを取得します。RH loginが必要になります。 

*↓以下の画面は、ACMコンソールではなく、 https://cloud.redhat.com/openshift/install/pull-secret[cloud.redhat.com] の画面です。*

image::images/acm-pullsecret.png[]

* Red Hat OpenShift pull secret: 取得したpull secret

* SSH private and public keys: 既存のキーペア　または　新規に生成したキーペア

新しいキーペアの作成については、次のドキュメントを参照して
https://docs.openshift.com/container-platform/4.9/installing/installing_aws/installing-aws-default.html#ssh-agent-using_installing-aws-default[新しいsshキーを生成]します。

> これらのキーを取得するには、*console.redhat.com* へのアクセスが必要な場合があることに注意してください。

* NEXTをクリックします。

image::images/acm-1-5.png[]

* 情報を確認し、*ADD* をクリックします。

image::images/acm-1-6.png[]

Credentialsが作成されたことがわかります。

image::images/acm-1-7.png[]

== AWSに新しいOpenShiftクラスターを作成する。

* メニューから *Infrastructure → Clusters* を選びます。
* *Create Cluster* をクリックします。

image::images/acm-2-1.png[]


* *Amazon Web services* を選択します。

image::images/acm-2-2.png[]


* *Infrastructure provider credential* は先程作成した *aws* を選択します。
* NEXTをクリックします

image::images/acm-2-1-1.png[]

* *cluster name* に名前を入力します。名前は適当でかまいません。
* *Cluster set* は空にしておきます。
* *Release Image* を選択します。 今回は「4.10.60」を選択してください。

image::images/acm-2-3.png[]

* *environment=prod* ラベルを付与します。
* NEXTをクリックします

image::images/acm-2-4.png[]

リージョンを *下表を参照* して変更します。今回は *ap-northeast-2* を選択してください。

|===
|ロケーション | 選択するAWS Region
|*NORTH AMERICA*|*us-west-1* または *us-west-2*

|*EUROPE / EMEA*|*eu-west-2* または *eu-west-3*
|*ASIA PACIFIC*|*ap-southeast-2* または *ap-northeast-2* または *ap-east-1*
|===


image::images/acm-2-5.png[]

* 画面でNEXTをクリックするか、メニューから *7 - Review* を選択し、*CREATE* をクリックします。

image::images/acm-2-6.png[]

_このプロセスは、本コース受講時のAWSのトラフィックに応じて、約30～40分かかります。失敗がないか必ずモニタし、必要に応じて対処してください_。

== AWSでシングルノードクラスター（SNO）を作成する。

メインクラスタのプロビジョニングを待つ間に、シングルノードクラスタのプロビジョニングを進めてみましょう。この演習では、テスト用のクラスタを構築する際の時間とリソースを節約するために、シングルノードクラスタを作成する方法を紹介します（OCP 4.8 以上が必要です）。

*Please NOTE：* SNOクラスターはベアメタルのみサポートし、パブリッククラウドは現在サポートされていません。以下の例では、機能を紹介するためにパブリッククラウドを活用しています。

「AWSに新しいOpenShiftクラスターを作成する。」と同様にAWS上にクラスターを作成します。

* メニューから *Infrastructure → Clusters* を選びます。
* *Create Cluster* をクリックします。
* *Amazon Web services* を選択します。
* *Infrastructure provider credential* は先程作成した *aws* を選択します。
* NEXTをクリックします

* *cluster name* に名前を入力します。名前は適当でかまいません。
* *Cluster set* は空にしておきます。
* *Release Image* を選択します。 今回は「4.10.60」を選択してください。

image::images/acm-3-1.png[]

* *environment=qa* ラベルを付与します。
* NEXTをクリックします

image::images/acm-3-2.png[]

リージョンを *下表を参照* して変更します。今回は *ap-northeast-2* を選択してください。

|===
|ロケーション | 選択するAWS Region
|*NORTH AMERICA*|*us-west-1* または *us-west-2*

|*EUROPE / EMEA*|*eu-west-2* または *eu-west-3*
|*ASIA PACIFIC*|*ap-southeast-2* または *ap-northeast-2* または *ap-east-1*
|===



* *Worker Pools* を展開し、Worker Node Countを 0 に変更します。

image::images/acm-3-2-1.png[]

image::images/acm-3-2-2.png[]

* *7 - Review* をクリックし、レビューする *前に*、画面上部の *YAML.* をONにします。

image::images/acm-3-3.png[]

image::images/acm-3-4.png[]

* YAMLウィンドウペインの *install-config* をクリックし、マスターレプリカの数を 1 に変更します（おそらく 3 になっています）。 ワーカーレプリカが 0 であることをダブルチェックします。

image::images/acm-3-5.png[]

image::images/acm-3-6.png[]

* YAMLウィンドウペインで *cluster* をクリックし、タイプ *kind: kind：MachinePool* オブジェクトを定義しているセクションを見つけます。*MachinePool* セクションの末尾に以下の行を追加します。

----
  skipMachinePools: true
----
追加した行が前の行と同じインデントであることを確認してください。

image::images/acm-3-7.png[]

image::images/acm-3-8.png[]

* *Create* をクリックすると、シングルノードクラスターの作成が実行されます。

_このプロセスは、本コース受講時のAWSのトラフィックに応じて、約10～20分かかります。失敗がないか必ずモニタし、必要に応じて対処してください_。

== Red Hat Advanced Cluster Management For Kubernetesによるアプリケーションの作成と管理

前のラボでは、RHACM の Cluster Lifecycle 機能を学習しました。これにより、新しい OpenShift® クラスターを作成し、アプリケーションのデプロイに使用することができました。

RHACMのアプリケーションライフサイクル機能は、管理対象クラスタ上のアプリケーションリソースを管理するために使用されるプロセスを提供します。これにより、Kubernetesの仕様を使用して単一、または複数クラスタのアプリケーションを定義することができ、個々のクラスタへのリソースの展開とライフサイクル管理の自動化が追加されます。

単一クラスタ上で実行するように設計されたアプリケーションは簡単で、OpenShiftの基本的な作業から慣れ親しんでいるはずのものです。マルチクラスターアプリケーションでは、アプリケーションコンポーネントを実行するクラスターについて定義した一連のルールに基づいて、複数のクラスターへの同じリソースのデプロイメントをオーケストレーションすることができます。

この表は、RHACM のアプリケーションライフサイクルモデルが構成するさまざまなコンポーネントを説明するものです。

|===
|*Resource* | *Purpose*

|Channel|オブジェクトストア、Kubernetesネームスペース、Helmリポジトリ、GitHubリポジトリなど、デプロイ可能なリソースが格納される場所を定義します。

|Subscription|Channelリソースで利用可能な、ターゲットクラスタにデプロイされるデプロイ可能なリソースを識別する定義。

|PlacementRule|Subscriptionがアプリケーションをデプロイして維持するターゲットクラスターを定義します。Subscriptionリソースで特定されたKubernetesリソースで構成され、Channelリソースで定義された場所から引き出されます。

|Application|コンポーネントをより見やすく1つのリソースにグループ化する方法です。アプリケーションリソースは、通常、Subscriptionリソースを参照します。

|===

これらはすべて、RHACMのインストール時に作成される、CRD（Custom Resource Definition）によって定義されたKubernetesカスタムリソースです。これらをKubernetesのネイティブオブジェクトとして作成することで、Podと同じように対話することができます。例えば、+oc get application+ を実行すると、+oc get pods+ がデプロイされたPodのリストを取得するのと同様に、デプロイされたRHACMアプリケーションのリストが取得されます。

これは、実際にアプリケーションを構成するdeployablesに加えて、管理する余分なリソースが多いように思えるかもしれません。しかし、多くのクラスタにデプロイする場合、アプリケーションの構成、配置、および全体的な制御を自動化することが可能になります。1つのクラスタであれば、ログインして +oc create -f...+ を実行するのは簡単ですが、それを何十ものクラスタで行う必要がある場合、ミスやクラスタの欠落がないようにしたいですし、アプリケーションの更新をスケジュールしてオーケストレーションする方法が必要です。RHACMのApplication Lifecycle Builderを活用することで、マルチクラスタのアプリケーションを簡単に管理することができます。

== アプリケーションを作成する

前提条件:

* *Infrastructure → Clusters* に移動します。
* *local-cluster* をクリックします。

image::images/acm-4-0-1.png[]

* *Labels* の下の *edit* ボタンをクリックして`environment=dev`というラベルを追加して、Saveします。

image::images/acm-4-0-2.png[]

image::images/acm-4-0-3.png[]

image::images/acm-4-0-4.png[]

* 構築した新しいクラスタに正しいラベルが貼られていることを確認します。
** *Local-Cluster* - `environment=dev`
** *AWS 1st Cluster* - `environment=prod`
** *AWS 2nd Cluster(SNO)* - `environment=qa`

image::images/acm-4-1.png[]


* *Applications* に移動します。
* *Create application, select Subscription* をクリックし次の情報を入力します。
** *Name*: `book-import`
** *Namespace*: `book-import`
** リポジトリの種類で、*GIT* リポジトリを選択します。
** *URL:*  https://github.com/hichammourad/book-import.git[https://github.com/hichammourad/book-import.git]
** *Branch*:  `master-no-pre-post`
** *Path:*  `book-import`

image::images/acm-4-2.png[]

image::images/acm-4-3.png[]

image::images/acm-4-4.png[]

* *Deploy application resources only on clusters matching specified labels* が選択されていることを確認し、次の情報を入力します。
** *Label*: `environment`
** *Value*: `dev`

* すべての情報が正しいことを確認します。*Create* をクリックします。

image::images/acm-4-5.png[]

アプリケーションのデプロイに数分かかりますので、*Topology* ビューをクリックして *すべてのチェックマークが緑色であること* を確認してください。

image::images/acm-4-6.png[]

image::images/acm-4-7.png[]


トポロジービューで、*Route* を選択し、*Launch Route* *URL* をクリックすると、ブックインポートアプリケーションが表示されます。

image::images/acm-4-8.png[]

image::images/acm-4-9.png[]

このアプリケーションを自由に試してみてください。 

編集して、ラベルを `environment=prod` に変えてみてください。 アプリケーションはどうなりますか？

これで *Application Lifecycle functionality in RHACM* の概要は完了です。

RHACMを使用してターゲットクラスタにアプリケーションを正常にデプロイしました。このアプローチでは、アプリケーションを定義するすべてのマニフェストが格納された Git リポジトリを活用しました。RHACMはこれらのマニフェストを受け取り、それらをdeployableとして使用し、ターゲットクラスタにデプロイすることができました。

また、ラベルの力を活用し、インポートしたクラスタにアプリケーションをデプロイすることもできます。ぜひ、ラベルで遊んでみて、このアプリケーションをローカル・クラスターにデプロイしてみてください。また、必要に応じて、他のクラスタやアプリケーションを作成することもできます。

== Governance, Risk, and Compliance（セキュリティとコンプライアンスのユースケース）

=== ACMでポリシーを作成する

この時点で、RHACM の Cluster Lifecycle と Application Lifecycle 機能の概要ラボを終了しています。クラスターライフサイクルラボでは、新しいクラスターのデプロイと既存のクラスターのインポートの両方を含め、RHACMがKubernetesクラスターのライフサイクルを管理するのに役立つ方法を学びました。そのラボでは、新しいクラスタを作成し、RHACMインスタンスを使用してそれらを管理しました。

アプリケーション・ライフサイクル・ラボでは、RHACM の機能を引き続き探索し、アプリケーションの展開と構成方法を学びました。アプリケーションのデプロイ先として、最初のワークショップモジュールで追加したクラスタを使用しました。

クラスタとデプロイされたアプリケーションを手に入れたら、それらが元の構成からドリフトしないことを確認する必要があります。このようなドリフトは、良心的で善良な修正や変更だけでなく、気づかないかもしれないが重大な問題を引き起こす悪意のある活動からも起こりうるため、深刻な問題です。これを解決するためにRHACMが提供するのが、Governance, Risk, and Compliance、つまりGRCの機能です。

==== GRC機能のレビュー

はじめに、GRCとは何かを正確に定義しておくことが重要です。RHACMでは、管理対象のクラスタに適用されるポリシーを構築します。これらのポリシーは、後述するようにさまざまなことを行うことができますが、最終的にはクラスタの構成を管理するためのものです。クラスタ構成に対するこのgovernanceは、riskを低減し、セキュリティチームや運用チームなどの利害関係者が定義した標準へのcomplianceを保証します。

この表は、RHACM で利用可能な 3 種類のポリシーコントローラと、それらがサポートする修復モードについて説明したものです。

|===
|*Policy Controller*| *Purpose* |*Enforce or Inform*

|Configuration|クラスタ全体で任意のKubernetesリソースを構成するために使用されます。これらのリソースが作成または設定される場所は、ポリシーに含める（または除外する）ネームスペースによって決定されます。|Both

|Certificate|期限切れ間近の証明書を検出するために使用します。コントローラポリシーの最小期間パラメータを更新することで、証明書ポリシーコントローラを構成することができます。証明書の有効期限が最小期間未満になると、ポリシーは非準拠となります。証明書は、含まれるネームスペースのsecretsから識別されます。|Inform

|Identity and Access Management (IAM)|コンプライアンス違反の IAM ポリシーに関する通知を受け取るために使用します。RHACMの1.0バージョンでは、クラスタで許可するクラスタ管理者の数が遵守されているかどうかをチェックするものです。|inform

|===

ポリシーコントローラーを実装するために、3種類のリソースを作成する必要があります。

|===
|*Resource*|*Function*

|Policy|Policyは、実際にチェックし、設定したい内容を定義します（enforceを使用）。ポリシーには、objectDefinition のリストを定義する policy-template が含まれます。また、ポリシーは、適用されるネームスペースと、実行される修復アクションを決定します。
|Placement Rule|このPlacementRuleを使用する際に対象となる管理対象クラスタのリストを識別します。
|PlacementBinding|PlacementRuleにポリシーを接続します。
|===


これは複雑なトピックであり、このコースは概要を提供するに過ぎません。これらのポリシーコントローラの詳細については https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.5/html-single/governance/index#governanc[GRC製品ドキュメント] を参照してください。

* *Governance* 画面に移動し、*create policy* をクリックします。

image::images/acm-5-1.png[]

image::images/acm-5-2.png[]

* GitHubのページで、すべてのポリシーを含む https://github.com/stolostron/policy-collection/tree/main/stable/CM-Configuration-Management に移動し、 https://github.com/stolostron/policy-collection/blob/main/stable/SC-System-and-Communications-Protection/policy-etcdencryption.yaml[policy-etcdencryption.yaml] を選択します。

* *policy-etcdencryption.yaml* のページで *RAW* ボタンをクリックします。

image::images/acm-5-3.png[]

* RAW YAMLをコピーします。

* *Create Policy* の画面で、*YAML* を有効にします。GitHub Repoからコピーした *RAW YAML* を貼り付けます。

* *Namespace*: `default`

image::images/acm-5-4.png[]

image::images/acm-5-5.png[]

image::images/acm-5-6.png[]

image::images/acm-5-7.png[]

* すべてが正しいことを確認します。

* *Submit* をクリックします。

image::images/acm-5-8.png[]

SubmitをクリックするとPolicyが作成され、スキャンが始まります。

image::images/acm-5-9.png[]

結果画面に移動し、スキャンが完了するのを待ちます。_3分以上かかることはありません_

image::images/acm-5-10.png[]

２つの違反が検知されますが、このポリシーは、Inform（情報提供）のみで作成されているため、違反の修正はできません。

続いて、違反の修正を行ってみましょう。Remediationを変更します。

* ポリシーの上部で、*Actions → Edit Policy* をクリックします

image::images/acm-5-11.png[]

* *ステップ2* を選択し、Remediationを *Enforce* に変更します。

image::images/acm-5-12.png[]

* *ステップ5* を選択し Remediationが *Enforce* に設定されているか確認します。

* *Submit* をクリックします。

image::images/acm-5-13.png[]

SubmitをクリックするとPolicyが変更され、スキャンが始まります。
結果画面に移動し、修復が完了するのを待ちます。片方の違反はすぐに修正されます。もう片方は修正に時間がかかります。

image::images/acm-5-14.png[]

最終的には、すべての違反が修正された状態になります。

image::images/acm-5-15.png[]

image::images/acm-5-16.png[]

これで、クラスタをスキャンするためのポリシーが作成できました。他のポリシーを試してみたい場合は、 https://github.com/stolostron/policy-collection[Policy Repo] にアクセスしてください。
