= Advanced Cluster Management for Kubernetes - RHACM

== クラスターとクラスターライフサイクルの操作

クラスターのライフサイクル管理は、マルチクラウド環境におけるクラスターの作成、アップグレード、破壊とインポートを高いレベルで行うものです。

本ワークショップ用のガイダンスページで、*ACM HubのURL*、*ユーザー名とパスワード*、*AWSの認証情報* 、*Access Key ID*  、*Secret Access Key ID*、*Base DNS Domain* を確認しておきます。

*ACM HubのURL* から *ユーザー名とパスワード* を使用してACMにログインした後、*Credentials menu* に移動し、*Add Credentials* を選択します。

=== 接続のための詳細情報の作成

* Cloud Provider Credentials: *Amazon Web Services* を選びます。
* Credential Name:  `aws`
* Namespace: `open-cluster-management`
* Base DNS Domain:  この情報は、本ワークショップ用のガイダンスページの *rhacm_aws_subdomain* というフィールドの下にあります。 

この情報をコピー＆ペーストする場合、URLのドットを必ず省略してください。例えば、`.sandbox1536.opentlc.com` ではなく、`sandbox1536.opentlc.com` と記述します。

* NEXTをクリックします。

* Access Key ID: この情報は、本ワークショップ用のガイダンスページの *rhacm_aws_access_key_id* というフィールドの下にあります。

* Secret Access Key ID: この情報は、本ワークショップ用のガイダンスページの *rhacm_aws_secret_key* というフィールドの下にあります。

* NEXTをクリックします。 

Proxyを設定する必要はないので、この画面は省略できます

* NEXTをクリックします。

* Red Hat OpenShift pull secret: https://cloud.redhat.com/openshift/install/pull-secret[cloud.redhat.com] から pull secretを取得します。RH loginが必要になります。 

* SSH private and public keys: 
既存のキーペアを使用するか、次のドキュメントを参照して
https://docs.openshift.com/container-platform/4.9/installing/installing_aws/installing-aws-default.html#ssh-agent-using_installing-aws-default[新しいsshキーを生成]します。

> これらのキーを取得するには、*console.redhat.com* へのアクセスが必要な場合があることに注意してください。

* NEXTをクリックします。

* 情報を確認し、*ADD* をクリックします。

== AWSに新しいOpenShiftクラスターを作成する。

* メニューから *Infrastructure → Clusters* を選びます。
* *Create Cluster* をクリックします。
* *Amazon Web services* を選択します。
* *Infrastructure provider credential* は先程作成した *AWS* を選択します。
* NEXTをクリックします
* *cluster name* に名前を入力します。
* *Cluster set* は空にしておきます。
* *Release Image* を選択します。 chose a 4.9 version
* *environment=prod* ラベルを付与します。
* NEXTをクリックします

リージョンを *下表を参照* して変更します。

|===
|ロケーション | 選択するAWS Region
|*NORTH AMERICA*|*us-west-1* または *us-west-2*

|*EUROPE / EMEA*|*eu-west-2* または *eu-west-3*
|*ASIA PACIFIC*|*ap-southeast-2* または *ap-northeast-2* または *ap-east-1*
|===

* 他の画面でNEXTをクリックするか、メニューから *7 - Review* を選択し、*CREATE* をクリックします。

_このプロセスは、本コース受講時のAWSのトラフィックに応じて、約30～40分かかります。失敗がないか必ずモニタし、必要に応じて対処してください_。

== AWSでシングルノードクラスター（SNO）を作成する。

メインクラスタのプロビジョニングを待つ間に、シングルノードクラスタのプロビジョニングを進めてみましょう。この演習では、テスト用のクラスタを構築する際の時間とリソースを節約するために、シングルノードクラスタを作成する方法を紹介します（OCP 4.8 以上が必要です）。

*Please NOTE：* SNOクラスターはベアメタルのみサポートし、パブリッククラウドは現在サポートされていません。以下の例では、機能を紹介するためにパブリッククラウドを活用しています。

* メニューから *Infrastructure → Clusters* を選びます。
* *Create Cluster* をクリックします。
* *Amazon Web services* を選択します。
* *Infrastructure provider credential* は先程作成した *AWS* を選択します。
* NEXTをクリックします
* *cluster name* に名前を入力します。
* *Cluster set* は空にしておきます。
* *Release Image* を選択します。 chose a 4.9 version
* *environment=qa* ラベルを付与します。
* NEXTをクリックします

リージョンを *下表を参照* して変更します。

|===
|ロケーション | 選択するAWS Region
|*NORTH AMERICA*|*us-west-1* または *us-west-2*

|*EUROPE / EMEA*|*eu-west-2* または *eu-west-3*
|*ASIA PACIFIC*|*ap-southeast-2* または *ap-northeast-2* または *ap-east-1*
|===

* *Worker Pools* を展開し、Worker Node Countを 0 に変更します。

* ステップ 7をクリックし、レビューする *前に*、画面上部の *YAML.* をONにします。

* YAMLウィンドウペインの *install-config* をクリックし、マスターレプリカの数を 1 に変更します（おそらく 3 になっています）。 ワーカーレプリカが 0 であることをダブルチェックします。

* YAMLウィンドウペインで *cluster* をクリックし、タイプ *kind: kind：MachinePool* オブジェクトを定義しているセクションを見つけます。*MachinePool* セクションの末尾に以下の行を追加します。

----
  skipMachinePools: true
----

追加した行が前の行と同じインデントであることを確認してください。

* *Create* をクリックすると、シングルノードクラスターの作成が実行されます。

_このプロセスは、本コース受講時のAWSのトラフィックに応じて、約10～20分かかります。失敗がないか必ずモニタし、必要に応じて対処してください_。

== Red Hat Advanced Cluster Management For Kubernetesによるアプリケーションの作成と管理

前のラボでは、RHACM の Cluster Lifecycle 機能を学習しました。これにより、新しい OpenShift® クラスターを作成し、アプリケーションのデプロイに使用することができました。

RHACMのアプリケーションライフサイクル機能は、管理対象クラスタ上のアプリケーションリソースを管理するために使用されるプロセスを提供します。これにより、Kubernetesの仕様を使用して単一、または複数クラスタのアプリケーションを定義することができ、個々のクラスタへのリソースの展開とライフサイクル管理の自動化が追加されます。

単一クラスタ上で実行するように設計されたアプリケーションは簡単で、OpenShiftの基本的な作業から慣れ親しんでいるはずのものです。マルチクラスターアプリケーションでは、アプリケーションコンポーネントを実行するクラスターについて定義した一連のルールに基づいて、複数のクラスターへの同じリソースのデプロイメントをオーケストレーションすることができます。

この表は、RHACM のアプリケーションライフサイクルモデルが構成するさまざまなコンポーネントを説明するものです。

|===
|*Resource* | *Purpose*

|Channel|オブジェクトストア、Kubernetesネームスペース、Helmリポジトリ、GitHubリポジトリなど、デプロイ可能なリソースが格納される場所を定義します。

|Subscription|Channelリソースで利用可能な、ターゲットクラスタにデプロイされるデプロイ可能なリソースを識別する定義。

|PlacementRule|Subscriptionがアプリケーションをデプロイして維持するターゲットクラスターを定義します。Subscriptionリソースで特定されたKubernetesリソースで構成され、Channelリソースで定義された場所から引き出されます。

|Application|コンポーネントをより見やすく1つのリソースにグループ化する方法です。アプリケーションリソースは、通常、Subscriptionリソースを参照します。

|===

これらはすべて、RHACMのインストール時に作成される、CRD（Custom Resource Definition）によって定義されたKubernetesカスタムリソースです。これらをKubernetesのネイティブオブジェクトとして作成することで、Podと同じように対話することができます。例えば、+oc get application+ を実行すると、+oc get pods+ がデプロイされたPodのリストを取得するのと同様に、デプロイされたRHACMアプリケーションのリストが取得されます。

これは、実際にアプリケーションを構成するdeployablesに加えて、管理する余分なリソースが多いように思えるかもしれません。しかし、多くのクラスタにデプロイする場合、アプリケーションの構成、配置、および全体的な制御を自動化することが可能になります。1つのクラスタであれば、ログインして +oc create -f...+ を実行するのは簡単ですが、それを何十ものクラスタで行う必要がある場合、ミスやクラスタの欠落がないようにしたいですし、アプリケーションの更新をスケジュールしてオーケストレーションする方法が必要です。RHACMのApplication Lifecycle Builderを活用することで、マルチクラスタのアプリケーションを簡単に管理することができます。

== アプリケーションを作成する

前提条件:

* *Infrastructure → Clusters* に移動します。
* *local-cluster* をクリックします。
* *Labels* の下の *edit* ボタンをクリックして`environment=dev`というラベルを追加します。
* 構築した新しいクラスタに正しいラベルが貼られていることを確認します。
** *Local-Cluster* - `environment=dev`
** *AWS 1st Cluster* - `environment=prod`
** *AWS 2nd Cluster* - `environment=qa`

* *Applications* に移動します。
* *Create application, select Subscription* をクリックし次の情報を入力します。
** *Name*: `book-import`
** *Namespace*: `book-import`
** リポジトリの種類で、*GIT* リポジトリを選択します。
** *URL:*  https://github.com/hichammourad/book-import.git[https://github.com/hichammourad/book-import.git]
** *Branch*:  `master-no-pre-post`
** *Path:*  `book-import`

* *Deploy application resources only on clusters matching specified labels* が選択されていることを確認し、次の情報を入力します。
** *Label*: `environment`
** *Value*: `dev`

* すべての情報が正しいことを確認します。*Create* をクリックします。

アプリケーションのデプロイに数分かかりますので、*Topology* ビューをクリックして *すべてのチェックマークが緑色であること* を確認してください。

トポロジービューで、*Route* を選択し、*Launch Route* *URL* をクリックすると、ブックインポートアプリケーションが表示されます。

このアプリケーションを自由に試してみてください。 
編集して、ラベルを `environment=prod` に変えてみてください。 アプリケーションはどうなりますか？

これで *Application Lifecycle functionality in RHACM.* の概要は完了です。

RHACMを使用してターゲットクラスタにアプリケーションを正常にデプロイしました。このアプローチでは、アプリケーションを定義するすべてのマニフェストが格納された Git リポジトリを活用しました。RHACMはこれらのマニフェストを受け取り、それらをdeployableとして使用し、ターゲットクラスタにデプロイすることができました。

また、ラベルの力を活用し、インポートしたクラスタにアプリケーションをデプロイすることもできます。ぜひ、ラベルで遊んでみて、このアプリケーションをローカル・クラスターにデプロイしてみてください。また、必要に応じて、他のクラスタやアプリケーションを作成することもできます。

== Governance, Risk, and Compliance（セキュリティとコンプライアンスのユースケース）

=== ACMでポリシーを作成する

この時点で、RHACM の Cluster Lifecycle と Application Lifecycle 機能の概要ラボを終了しています。クラスターライフサイクルラボでは、新しいクラスターのデプロイと既存のクラスターのインポートの両方を含め、RHACMがKubernetesクラスターのライフサイクルを管理するのに役立つ方法を学びました。そのラボでは、新しいクラスタを作成し、RHACMインスタンスを使用してそれらを管理しました。

アプリケーション・ライフサイクル・ラボでは、RHACM の機能を引き続き探索し、アプリケーションの展開と構成方法を学びました。アプリケーションのデプロイ先として、最初のワークショップモジュールで追加したクラスタを使用しました。

クラスタとデプロイされたアプリケーションを手に入れたら、それらが元の構成からドリフトしないことを確認する必要があります。このようなドリフトは、良心的で善良な修正や変更だけでなく、気づかないかもしれないが重大な問題を引き起こす悪意のある活動からも起こりうるため、深刻な問題です。これを解決するためにRHACMが提供するのが、Governance, Risk, and Compliance、つまりGRCの機能です。

==== GRC機能のレビュー

はじめに、GRCとは何かを正確に定義しておくことが重要です。RHACMでは、管理対象のクラスタに適用されるポリシーを構築します。これらのポリシーは、後述するようにさまざまなことを行うことができますが、最終的にはクラスタの構成を管理するためのものです。クラスタ構成に対するこのgovernanceは、riskを低減し、セキュリティチームや運用チームなどの利害関係者が定義した標準へのcomplianceを保証します。

この表は、RHACM で利用可能な 3 種類のポリシーコントローラと、それらがサポートする修復モードについて説明したものです。

|===
|*Policy Controller*| *Purpose* |*Enforce or Inform*

|Configuration|クラスタ全体で任意のKubernetesリソースを構成するために使用されます。これらのリソースが作成または設定される場所は、ポリシーに含める（または除外する）ネームスペースによって決定されます。|Both

|Certificate|期限切れ間近の証明書を検出するために使用します。コントローラポリシーの最小期間パラメータを更新することで、証明書ポリシーコントローラを構成することができます。証明書の有効期限が最小期間未満になると、ポリシーは非準拠となります。証明書は、含まれるネームスペースのsecretsから識別されます。|Inform

|Identity and Access Management (IAM)|コンプライアンス違反の IAM ポリシーに関する通知を受け取るために使用します。RHACMの1.0バージョンでは、クラスタで許可するクラスタ管理者の数が遵守されているかどうかをチェックするものです。|inform

|===

ポリシーコントローラーを実装するために、3種類のリソースを作成する必要があります。

|===
|*Resource*|*Function*

|Policy|Policyは、実際にチェックし、設定したい内容を定義します（enforceを使用）。ポリシーには、objectDefinition のリストを定義する policy-template が含まれます。また、ポリシーは、適用されるネームスペースと、実行される修復アクションを決定します。
|Placement Rule|このPlacementRuleを使用する際に対象となる管理対象クラスタのリストを識別します。
|PlacementBinding|PlacementRuleにポリシーを接続します。
|===


これは複雑なトピックであり、このコースは概要を提供するに過ぎません。これらのポリシーコントローラの詳細については https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.5/html-single/governance/index#governanc[GRC製品ドキュメント] を参照してください。

* *Governance* 画面に移動し、*create policy* をクリックします。

* すべてのポリシーを含む https://github.com/stolostron/policy-collection/tree/main/stable/CM-Configuration-Management[GitHub Repo]に移動し、 https://github.com/stolostron/policy-collection/blob/main/stable/SC-System-and-Communications-Protection/policy-etcdencryption.yaml[Etcd Encryption] を選択します。

* *ETCD Encryption Policy* 上で、*RAW* ボタンをクリックします。

* RAW YAMLをコピーします。

* *Create Policy* の画面で、*YAML* を有効にします。GitHub Repoから *RAW YAML* をコピーして貼り付けます。

* *Namespace*: `default`

* *ステップ5* をクリックし、すべてが正しいことを確認します。

* *Submit* をクリックします。

結果画面に移動し、スキャンが完了するのを待ちます。_3分以上かかることはありません_

このポリシーは、Inform（情報提供）のみで作成されているため、違反の修正はできませんが、先に進んで修正しましょう。

* ポリシーの上部で、*Actions → Edit Policy* をクリックします

* *ステップ2* を選択し、Remediationを *Enforce* に変更します。

* *ステップ5* を選択し Remediationが *Enforce* に設定されているか確認します。

* *Submit* をクリックします。

結果画面に移動し、修復が完了するのを待ちます。 _3分以上かかることはありません_

これで、クラスタをスキャンするためのポリシーが作成できました。他のポリシーを試してみたい場合は、 https://github.com/stolostron/policy-collection[Policy Repo] にアクセスしてください。

